#!/usr/bin/env python3
"""
CLI for restoring planner sessions from exported artifacts.

Verifies artifact integrity, reconstructs the serialized `HLayerState`, and
persists it for continued planning.
"""

from __future__ import annotations

import argparse
import json
import sys
import zipfile
from datetime import datetime, timezone
from pathlib import Path

import torch

from src.core.planner import restore_state_from_artifact
from src.models.planning.session_artifact import PlannerSessionArtifact, TensorResolutionError


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Restore a planner session from an exported artifact bundle.",
    )
    parser.add_argument(
        "--artifact",
        type=Path,
        required=True,
        help="Path to the artifact zip generated by session_export.",
    )
    parser.add_argument(
        "--out-state",
        type=Path,
        help="Path to persist the restored HLayerState (defaults to sessions/<session-id>.state.pt).",
    )
    parser.add_argument(
        "--target-session-id",
        type=str,
        help="Optional override for the resulting session id.",
    )
    parser.add_argument(
        "--device",
        type=str,
        default="cpu",
        help="Device for restored tensors (default: cpu).",
    )
    parser.add_argument(
        "--allow-version-mismatch",
        action="store_true",
        help="Disable strict artifact version checks when restoring.",
    )
    return parser.parse_args()


def _load_artifact_manifest(bundle: zipfile.ZipFile) -> PlannerSessionArtifact:
    try:
        manifest_bytes = bundle.read("artifact.json")
    except KeyError as exc:
        raise FileNotFoundError("artifact.json not found in bundle") from exc
    manifest = json.loads(manifest_bytes.decode("utf-8"))
    return PlannerSessionArtifact.from_dict(manifest)


def main() -> None:
    args = parse_args()

    if not args.artifact.exists():
        sys.exit(f"Artifact bundle not found: {args.artifact}")

    with zipfile.ZipFile(args.artifact, mode="r") as bundle:
        try:
            artifact = _load_artifact_manifest(bundle)
        except (FileNotFoundError, json.JSONDecodeError, KeyError) as exc:
            sys.exit(f"Failed to load artifact manifest: {exc}")

        def loader(storage_path: str) -> bytes:
            try:
                return bundle.read(storage_path)
            except KeyError as exc:
                raise TensorResolutionError(storage_path) from exc

        try:
            restored_state = restore_state_from_artifact(
                artifact,
                loader,
                device=torch.device(args.device),
                target_session_id=args.target_session_id,
                strict_version_check=not args.allow_version_mismatch,
            )
        except (ValueError, TensorResolutionError) as exc:
            sys.exit(f"Failed to restore session: {exc}")

    resolved_session_id = restored_state.episode_id
    state_path = args.out_state or Path("sessions") / f"{resolved_session_id}.state.pt"
    state_path.parent.mkdir(parents=True, exist_ok=True)
    torch.save(restored_state, state_path)

    routing = artifact.routing_metadata
    restored_at = datetime.now(timezone.utc).isoformat()
    print(f"Restored session {resolved_session_id} at {restored_at}")
    print(f"state_path={state_path}")
    print(f"step={routing.step}")
    print(f"threshold_history={list(routing.threshold_history)}")
    print(f"last_selected_engines={list(routing.last_selected_engines)}")
    print(f"last_confidence={routing.last_confidence}")
    print(f"context_snapshot_hash={artifact.context_snapshot_hash}")


if __name__ == "__main__":
    main()

